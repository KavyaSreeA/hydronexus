<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-time Monitoring - HydroNexus</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
    
    <!-- Styles -->
    <link rel="stylesheet" href="/css/main.css">
    
    <style>
        .monitoring-header {
            background: linear-gradient(135deg, #1a365d 0%, #2d3748 100%);
            color: white;
            padding: 1.5rem 0;
        }
        
        .monitoring-header .container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .monitoring-header h1 {
            font-size: 1.5rem;
        }
        
        .live-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            font-size: 0.875rem;
        }
        
        .live-dot {
            width: 10px;
            height: 10px;
            background: #68d391;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .monitoring-grid {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 1.5rem;
            padding: 1.5rem;
            min-height: calc(100vh - 100px);
        }
        
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .stats-card {
            background: white;
            border-radius: 12px;
            padding: 1.25rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        
        .stats-card h3 {
            font-size: 0.875rem;
            color: #718096;
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .stat-row:last-child {
            border-bottom: none;
        }
        
        .stat-label {
            color: #4a5568;
            font-size: 0.875rem;
        }
        
        .stat-value {
            font-weight: 600;
            font-size: 1.125rem;
        }
        
        .stat-value.normal { color: #38a169; }
        .stat-value.warning { color: #d69e2e; }
        .stat-value.critical { color: #e53e3e; }
        
        .nodes-list {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            overflow: hidden;
            flex: 1;
        }
        
        .nodes-list-header {
            padding: 1rem 1.25rem;
            background: #f7fafc;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .nodes-list-header h3 {
            font-size: 1rem;
            color: #2d3748;
        }
        
        .filter-btn {
            padding: 0.375rem 0.75rem;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 0.75rem;
            cursor: pointer;
        }
        
        .filter-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
        
        .nodes-list-content {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .node-item {
            padding: 1rem 1.25rem;
            border-bottom: 1px solid #e2e8f0;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .node-item:hover {
            background: #f7fafc;
        }
        
        .node-item.selected {
            background: #eef2ff;
            border-left: 3px solid #667eea;
        }
        
        .node-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .node-id {
            font-weight: 600;
            color: #2d3748;
        }
        
        .node-status {
            padding: 0.25rem 0.625rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
        }
        
        .node-status.normal { background: #c6f6d5; color: #276749; }
        .node-status.warning { background: #fefcbf; color: #975a16; }
        .node-status.critical { background: #fed7d7; color: #c53030; }
        .node-status.offline { background: #e2e8f0; color: #4a5568; }
        
        .node-name {
            font-size: 0.875rem;
            color: #718096;
        }
        
        .node-metrics {
            display: flex;
            gap: 1rem;
            margin-top: 0.75rem;
        }
        
        .metric {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            font-size: 0.75rem;
            color: #718096;
        }
        
        .metric-value {
            font-weight: 600;
            color: #2d3748;
        }
        
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        
        .map-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            flex: 1;
            min-height: 500px;
            position: relative;
            overflow: hidden;
        }

        #monitoringMap {
            width: 100%;
            height: 100%;
            min-height: 500px;
            border-radius: 12px;
            z-index: 1;
        }

        .map-legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: white;
            border-radius: 10px;
            padding: 12px 16px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            z-index: 1000;
            font-size: 0.75rem;
        }

        .map-legend h4 {
            font-size: 0.8rem;
            color: #2d3748;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .map-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .map-legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .map-controls {
            position: absolute;
            top: 12px;
            right: 12px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .map-control-btn {
            background: white;
            border: none;
            border-radius: 8px;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.12);
            font-size: 1rem;
            transition: all 0.2s;
        }

        .map-control-btn:hover {
            background: #f7fafc;
            transform: scale(1.05);
        }

        .leaflet-popup-content-wrapper {
            border-radius: 10px !important;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15) !important;
        }

        .leaflet-popup-content {
            margin: 12px 16px !important;
            font-family: 'Inter', sans-serif !important;
        }

        .popup-node-name {
            font-weight: 600;
            color: #2d3748;
            font-size: 0.9rem;
            margin-bottom: 4px;
        }

        .popup-node-type {
            font-size: 0.75rem;
            color: #718096;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .popup-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .popup-metric {
            background: #f7fafc;
            padding: 6px 8px;
            border-radius: 6px;
        }

        .popup-metric-label {
            font-size: 0.625rem;
            color: #a0aec0;
            text-transform: uppercase;
        }

        .popup-metric-value {
            font-size: 0.875rem;
            font-weight: 600;
            color: #2d3748;
        }

        .popup-status {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            margin-top: 8px;
        }

        .popup-status.normal { background: #c6f6d5; color: #276749; }
        .popup-status.warning { background: #fefcbf; color: #975a16; }
        .popup-status.critical { background: #fed7d7; color: #c53030; animation: pulse-bg 1.5s infinite; }

        @keyframes pulse-bg {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .alerts-panel {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        
        .alerts-header {
            padding: 1rem 1.25rem;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .alerts-header h3 {
            font-size: 1rem;
            color: #2d3748;
        }
        
        .alert-count {
            background: #e53e3e;
            color: white;
            padding: 0.125rem 0.5rem;
            border-radius: 10px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .alerts-list {
            max-height: 200px;
            overflow-y: auto;
        }
        
        .alert-item {
            padding: 0.875rem 1.25rem;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            gap: 1rem;
            align-items: flex-start;
        }
        
        .alert-icon {
            font-size: 1.25rem;
        }
        
        .alert-content {
            flex: 1;
        }
        
        .alert-title {
            font-weight: 500;
            color: #2d3748;
            margin-bottom: 0.25rem;
        }
        
        .alert-meta {
            font-size: 0.75rem;
            color: #718096;
        }
        
        .alert-severity {
            padding: 0.125rem 0.5rem;
            border-radius: 4px;
            font-size: 0.625rem;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .alert-severity.critical { background: #fed7d7; color: #c53030; }
        .alert-severity.high { background: #feebc8; color: #c05621; }
        .alert-severity.medium { background: #fefcbf; color: #975a16; }
        .alert-severity.low { background: #c6f6d5; color: #276749; }
        
        .no-alerts {
            padding: 2rem;
            text-align: center;
            color: #a0aec0;
        }
        
        .progress-bar {
            height: 6px;
            background: #e2e8f0;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 0.25rem;
        }
        
        .progress-fill {
            height: 100%;
            transition: width 0.3s;
        }
        
        .progress-fill.low { background: #38a169; }
        .progress-fill.medium { background: #d69e2e; }
        .progress-fill.high { background: #e53e3e; }

        /* Monitoring responsive */
        @media (max-width: 768px) {
            .monitoring-grid {
                grid-template-columns: 1fr;
                padding: 1rem;
                gap: 1rem;
            }
            .monitoring-header .container {
                flex-direction: column;
                gap: 0.75rem;
                text-align: center;
            }
            .monitoring-header h1 {
                font-size: 1.2rem;
            }
            .sidebar {
                position: static;
                width: 100%;
                height: auto;
                border-right: none;
            }
            .nodes-list-content {
                max-height: 250px;
            }
            .map-container {
                min-height: 280px;
            }
            .node-metrics {
                gap: 0.5rem;
            }
        }
    </style>
</head>
<body style="background: #f0f4f8;">
    <div class="monitoring-header">
        <div class="container">
            <div>
                <a href="/" style="color: white; text-decoration: none;">
                    <h1>üåä HydroNexus Monitoring</h1>
                </a>
            </div>
            <div class="live-indicator">
                <div class="live-dot"></div>
                <span>Live Data</span>
            </div>
        </div>
    </div>
    
    <div class="monitoring-grid">
        <div class="sidebar">
            <!-- System Stats -->
            <div class="stats-card">
                <h3>System Overview</h3>
                <div class="stat-row">
                    <span class="stat-label">Active Nodes</span>
                    <span class="stat-value" id="activeNodes">--</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Normal</span>
                    <span class="stat-value normal" id="normalCount">--</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Warning</span>
                    <span class="stat-value warning" id="warningCount">--</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Critical</span>
                    <span class="stat-value critical" id="criticalCount">--</span>
                </div>
            </div>
            
            <!-- Average Metrics -->
            <div class="stats-card">
                <h3>Average Metrics</h3>
                <div class="stat-row">
                    <span class="stat-label">Water Level</span>
                    <span class="stat-value" id="avgWaterLevel">--%</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill low" id="waterLevelBar" style="width: 0%"></div>
                </div>
            </div>
            
            <!-- Nodes List -->
            <div class="nodes-list">
                <div class="nodes-list-header">
                    <h3>Drainage Nodes</h3>
                    <div class="filters">
                        <button class="filter-btn active" data-filter="all">All</button>
                        <button class="filter-btn" data-filter="critical">Critical</button>
                    </div>
                </div>
                <div class="nodes-list-content" id="nodesList">
                    <div class="no-alerts">Loading nodes...</div>
                </div>
            </div>
        </div>
        
        <div class="main-content">
            <!-- Interactive Leaflet Map -->
            <div class="map-container">
                <div id="monitoringMap"></div>
                <div class="map-controls">
                    <button class="map-control-btn" onclick="fitAllNodes()" title="Fit all nodes">üìç</button>
                    <button class="map-control-btn" onclick="toggleHeatOverlay()" title="Toggle risk overlay">üå°Ô∏è</button>
                    <button class="map-control-btn" onclick="refreshMapData()" title="Refresh data">üîÑ</button>
                </div>
                <div class="map-legend">
                    <h4>Node Status</h4>
                    <div class="map-legend-item">
                        <div class="map-legend-dot" style="background: #22c55e;"></div>
                        <span>Normal</span>
                    </div>
                    <div class="map-legend-item">
                        <div class="map-legend-dot" style="background: #f59e0b;"></div>
                        <span>Warning</span>
                    </div>
                    <div class="map-legend-item">
                        <div class="map-legend-dot" style="background: #ef4444;"></div>
                        <span>Critical</span>
                    </div>
                    <div class="map-legend-item">
                        <div class="map-legend-dot" style="background: #6b7280;"></div>
                        <span>Offline</span>
                    </div>
                </div>
            </div>
            
            <!-- Active Alerts -->
            <div class="alerts-panel">
                <div class="alerts-header">
                    <h3>üö® Active Alerts</h3>
                    <span class="alert-count" id="alertCount">0</span>
                </div>
                <div class="alerts-list" id="alertsList">
                    <div class="no-alerts">No active alerts</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Initialize Socket.IO connection
        const socket = io();
        
        socket.on('connect', () => {
            console.log('Connected to server');
            socket.emit('join-room', 'monitoring');
        });
        
        // ==================== MAP ====================
        let monitoringMap = null;
        let mapMarkers = [];
        let markerGroup = null;
        let heatOverlayVisible = false;
        let heatCircles = [];
        let nodesCache = [];

        function initMap() {
            const container = document.getElementById('monitoringMap');
            if (!container || monitoringMap) return;

            try {
                monitoringMap = L.map('monitoringMap', {
                    zoomControl: false
                }).setView([28.6139, 77.2090], 14);

                // Styled tile layer (CartoDB Positron for a clean look)
                L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> &copy; <a href="https://carto.com/">CARTO</a>',
                    maxZoom: 19
                }).addTo(monitoringMap);

                // Add zoom control to bottom-right
                L.control.zoom({ position: 'bottomright' }).addTo(monitoringMap);

                markerGroup = L.featureGroup().addTo(monitoringMap);

                console.log('‚úÖ Monitoring map initialized');
            } catch (err) {
                console.error('Map init error:', err);
                container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#718096;"><p>Map could not be loaded</p></div>';
            }
        }

        function addNodesToMap(nodes) {
            if (!monitoringMap || !markerGroup) return;

            // Clear existing markers
            markerGroup.clearLayers();
            mapMarkers = [];
            heatCircles.forEach(c => monitoringMap.removeLayer(c));
            heatCircles = [];
            nodesCache = nodes;

            const statusColors = {
                normal: '#22c55e',
                warning: '#f59e0b',
                critical: '#ef4444',
                offline: '#6b7280'
            };

            const statusPulse = {
                normal: false,
                warning: false,
                critical: true,
                offline: false
            };

            nodes.forEach(node => {
                const lat = node.location?.coordinates?.lat;
                const lng = node.location?.coordinates?.lng;
                if (!lat || !lng) return;

                const status = node.currentStatus?.operationalStatus || 'normal';
                const color = statusColors[status] || '#22c55e';
                const waterLevel = node.currentStatus?.waterLevel?.current || 0;
                const blockage = node.currentStatus?.blockageLevel?.current || 0;
                const flowRate = node.currentStatus?.flowRate?.current || 0;

                // Create pulsing marker for critical nodes
                const pulseClass = statusPulse[status] ? 'marker-pulse' : '';
                const markerHtml = `
                    <div class="custom-marker ${pulseClass}" style="
                        background: ${color};
                        width: 20px;
                        height: 20px;
                        border-radius: 50%;
                        border: 3px solid white;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                        position: relative;
                    ">
                        <span style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            font-size: 10px;
                            color: white;
                            font-weight: bold;
                        ">${status === 'critical' ? '!' : ''}</span>
                    </div>
                    ${statusPulse[status] ? `<div style="
                        position: absolute;
                        top: -4px;
                        left: -4px;
                        width: 28px;
                        height: 28px;
                        border-radius: 50%;
                        border: 2px solid ${color};
                        opacity: 0;
                        animation: marker-ring 1.5s ease-out infinite;
                    "></div>` : ''}
                `;

                const icon = L.divIcon({
                    className: 'leaflet-marker-custom',
                    html: markerHtml,
                    iconSize: [26, 26],
                    iconAnchor: [13, 13],
                    popupAnchor: [0, -16]
                });

                const marker = L.marker([lat, lng], { icon })
                    .addTo(markerGroup)
                    .bindPopup(`
                        <div style="min-width: 200px;">
                            <div class="popup-node-name">${node.name}</div>
                            <div class="popup-node-type">${(node.type || '').replace('_', ' ')}</div>
                            <div class="popup-metrics">
                                <div class="popup-metric">
                                    <div class="popup-metric-label">Water Level</div>
                                    <div class="popup-metric-value">${waterLevel}%</div>
                                </div>
                                <div class="popup-metric">
                                    <div class="popup-metric-label">Blockage</div>
                                    <div class="popup-metric-value">${blockage}%</div>
                                </div>
                                <div class="popup-metric">
                                    <div class="popup-metric-label">Flow Rate</div>
                                    <div class="popup-metric-value">${flowRate} L/s</div>
                                </div>
                                <div class="popup-metric">
                                    <div class="popup-metric-label">Node ID</div>
                                    <div class="popup-metric-value">${node.nodeId}</div>
                                </div>
                            </div>
                            <div class="popup-status ${status}">${status.toUpperCase()}</div>
                        </div>
                    `, { maxWidth: 260 });

                marker._nodeId = node.nodeId;
                mapMarkers.push(marker);

                // Add risk heat circle (always present, toggled with button)
                const riskRadius = Math.max(waterLevel, blockage) * 3 + 50;
                const heatCircle = L.circle([lat, lng], {
                    radius: riskRadius,
                    fillColor: color,
                    fillOpacity: heatOverlayVisible ? 0.15 : 0,
                    color: color,
                    weight: heatOverlayVisible ? 1 : 0,
                    opacity: heatOverlayVisible ? 0.3 : 0
                }).addTo(monitoringMap);
                heatCircles.push(heatCircle);
            });

            // Fit map to markers
            if (mapMarkers.length > 0) {
                monitoringMap.fitBounds(markerGroup.getBounds().pad(0.3));
            }
        }

        function addAlertsToMap(alerts) {
            if (!monitoringMap || !alerts) return;

            alerts.forEach(alert => {
                const lat = alert.location?.coordinates?.lat;
                const lng = alert.location?.coordinates?.lng;
                if (!lat || !lng) return;

                const severityColors = {
                    critical: '#ef4444',
                    high: '#f59e0b',
                    medium: '#3b82f6',
                    low: '#22c55e'
                };
                const color = severityColors[alert.severity] || '#f59e0b';

                L.marker([lat, lng], {
                    icon: L.divIcon({
                        className: 'leaflet-marker-custom',
                        html: `<div style="
                            background: ${color};
                            color: white;
                            width: 24px;
                            height: 24px;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-weight: bold;
                            font-size: 14px;
                            border: 2px solid white;
                            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                        ">‚ö†</div>`,
                        iconSize: [24, 24],
                        iconAnchor: [12, 12],
                        popupAnchor: [0, -14]
                    })
                }).addTo(markerGroup).bindPopup(`
                    <div style="min-width: 180px;">
                        <div class="popup-node-name">üö® ${alert.title}</div>
                        <p style="font-size: 0.8rem; color: #4a5568; margin: 6px 0;">${alert.message || ''}</p>
                        <div class="popup-status ${alert.severity}">${(alert.severity || '').toUpperCase()}</div>
                    </div>
                `);
            });
        }

        function fitAllNodes() {
            if (markerGroup && mapMarkers.length > 0) {
                monitoringMap.fitBounds(markerGroup.getBounds().pad(0.3));
            }
        }

        function toggleHeatOverlay() {
            heatOverlayVisible = !heatOverlayVisible;
            const statusColors = { normal: '#22c55e', warning: '#f59e0b', critical: '#ef4444', offline: '#6b7280' };

            heatCircles.forEach((circle, i) => {
                const node = nodesCache[i];
                const status = node?.currentStatus?.operationalStatus || 'normal';
                const color = statusColors[status] || '#22c55e';
                circle.setStyle({
                    fillOpacity: heatOverlayVisible ? 0.15 : 0,
                    weight: heatOverlayVisible ? 1 : 0,
                    opacity: heatOverlayVisible ? 0.3 : 0
                });
            });
        }

        function refreshMapData() {
            fetchData();
        }

        // Highlight node on map when sidebar item is clicked
        function focusNodeOnMap(nodeId) {
            const marker = mapMarkers.find(m => m._nodeId === nodeId);
            if (marker && monitoringMap) {
                monitoringMap.setView(marker.getLatLng(), 16, { animate: true });
                marker.openPopup();
            }
        }

        // Add keyframe for marker pulse ring
        const pulseStyle = document.createElement('style');
        pulseStyle.textContent = `
            @keyframes marker-ring {
                0% { transform: scale(1); opacity: 0.6; }
                100% { transform: scale(2.5); opacity: 0; }
            }
            .leaflet-marker-custom { background: transparent !important; border: none !important; }
        `;
        document.head.appendChild(pulseStyle);

        // ==================== DATA ====================

        // Fetch initial data
        async function fetchData() {
            try {
                // Fetch drainage statistics
                const statsRes = await fetch('/api/drainage/statistics');
                const statsData = await statsRes.json();
                
                if (statsData.success) {
                    const data = statsData.data;
                    document.getElementById('activeNodes').textContent = data.totalNodes || 0;
                    document.getElementById('normalCount').textContent = data.statusCounts?.normal || 0;
                    document.getElementById('warningCount').textContent = data.statusCounts?.warning || 0;
                    document.getElementById('criticalCount').textContent = data.statusCounts?.critical || 0;
                    
                    const avgWl = Math.round(data.avgWaterLevel || 0);
                    document.getElementById('avgWaterLevel').textContent = avgWl + '%';
                    
                    const bar = document.getElementById('waterLevelBar');
                    bar.style.width = avgWl + '%';
                    bar.className = 'progress-fill ' + (avgWl >= 70 ? 'high' : avgWl >= 40 ? 'medium' : 'low');
                }
                
                // Fetch nodes
                const nodesRes = await fetch('/api/drainage');
                const nodesData = await nodesRes.json();
                
                if (nodesData.success) {
                    const nodes = nodesData.data.nodes || nodesData.data || [];
                    renderNodes(nodes);
                    addNodesToMap(nodes);
                }
                
                // Fetch active alerts
                const alertsRes = await fetch('/api/alerts/active');
                const alertsData = await alertsRes.json();
                
                if (alertsData.success) {
                    const alerts = alertsData.data.alerts || alertsData.data || [];
                    renderAlerts(alerts);
                    addAlertsToMap(alerts);
                    document.getElementById('alertCount').textContent = alertsData.data.count || alerts.length || 0;
                }
            } catch (error) {
                console.error('Failed to fetch data:', error);
            }
        }
        
        function renderNodes(nodes) {
            const container = document.getElementById('nodesList');
            
            if (!nodes || nodes.length === 0) {
                container.innerHTML = '<div class="no-alerts">No nodes found</div>';
                return;
            }
            
            container.innerHTML = nodes.map(node => {
                const status = node.currentStatus?.operationalStatus || 'normal';
                const waterLevel = node.currentStatus?.waterLevel?.current || 0;
                const blockage = node.currentStatus?.blockageLevel?.current || 0;
                
                return `
                    <div class="node-item" data-node-id="${node.nodeId}" onclick="focusNodeOnMap('${node.nodeId}')" style="cursor: pointer;">
                        <div class="node-item-header">
                            <span class="node-id">${node.nodeId}</span>
                            <span class="node-status ${status}">${status}</span>
                        </div>
                        <div class="node-name">${node.name}</div>
                        <div class="node-metrics">
                            <div class="metric">
                                üíß <span class="metric-value">${waterLevel}%</span>
                            </div>
                            <div class="metric">
                                üö´ <span class="metric-value">${blockage}%</span>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function renderAlerts(alerts) {
            const container = document.getElementById('alertsList');
            
            if (!alerts || alerts.length === 0) {
                container.innerHTML = '<div class="no-alerts">No active alerts</div>';
                return;
            }
            
            container.innerHTML = alerts.map(alert => {
                const icon = {
                    'flood_warning': 'üåä',
                    'drainage_blockage': 'üö´',
                    'overflow_risk': '‚ö†Ô∏è',
                    'maintenance_required': 'üîß',
                    'sensor_malfunction': 'üì°',
                    'emergency': 'üö®'
                }[alert.type] || '‚ö°';
                
                const time = new Date(alert.timeline?.createdAt).toLocaleString();
                
                return `
                    <div class="alert-item">
                        <span class="alert-icon">${icon}</span>
                        <div class="alert-content">
                            <div class="alert-title">${alert.title}</div>
                            <div class="alert-meta">${time}</div>
                        </div>
                        <span class="alert-severity ${alert.severity}">${alert.severity}</span>
                    </div>
                `;
            }).join('');
        }
        
        // Real-time updates
        socket.on('sensor-update', (data) => {
            console.log('Sensor update:', data);
            fetchData(); // Refresh data
        });
        
        socket.on('new-alert', (alert) => {
            console.log('New alert:', alert);
            fetchData(); // Refresh alerts
        });
        
        socket.on('alert-updated', (data) => {
            console.log('Alert updated:', data);
            fetchData();
        });
        
        // Filter buttons
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', async () => {
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                const filter = btn.dataset.filter;
                let url = '/api/drainage';
                
                if (filter !== 'all') {
                    url = `/api/drainage/status/${filter}`;
                }
                
                try {
                    const res = await fetch(url);
                    const data = await res.json();
                    renderNodes(data.data.nodes);
                } catch (error) {
                    console.error('Filter error:', error);
                }
            });
        });
        
        // Initialize map and load data
        initMap();
        fetchData();
        
        // Refresh every 30 seconds
        setInterval(fetchData, 30000);
    </script>
</body>
</html>
